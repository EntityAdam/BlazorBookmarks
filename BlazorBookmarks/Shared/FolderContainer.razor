@inject NavigationManager navigationManager
@inject IFacade facade

@if (IsEditMode && BookmarkToEdit != null)
{
    <CascadingValue Value="@this">
        <EditBookmark BookmarkToEdit="BookmarkToEdit" />
    </CascadingValue>
}
else
{
    <!-- removed @onkeypress:preventDefault, this blocked child <input/> elements -->
    <div class="flex flex-wrap items-baseline bg-black"
         tabindex="1"
         @onkeypress="((e) => HandleKeyPress(e))">
        <CascadingValue Value="@this">
            @foreach (var folder in CurrentState.Folders)
            {
                <Folder Model="@folder" />
            }
            <Addfolder />
        </CascadingValue>
    </div>
}

@code {

    [Parameter]
    public StateModelUi CurrentState { get; set; }

    [Parameter]
    public EventCallback SnapShotCallback { get; set; }

    [Parameter]
    public EventCallback UndoCallback { get; set; }

    [Parameter]
    public EventCallback RedoCallback { get; set; }

    public FolderModelUi FolderDragPayload { get; set; }

    public BookmarkModelUi BookmarkDragPayload { get; set; }

    private bool IsEditMode { get; set; } = false;
    private BookmarkModelUi BookmarkToEdit { get; set; }

    public async Task EditFolderTitle(int folderId, string folderName)
    {
        //this is the correct pattern!! fix everything else
        var folder = CurrentState.Folders.Single(x => x.Id == folderId);
        folder.Name = folderName;
        await SnapShotCallback.InvokeAsync();
    }

    public async Task IncrementClicks(int bookmarkId)
    {
        var bookmark = CurrentState.Bookmarks.Single(x => x.Id == bookmarkId);
        bookmark.Clicks++;
        await SnapShotCallback.InvokeAsync(); //TODO this should be save, not snapsot. doesn't make sense to undo/redo
    }

    public async Task AddFolder(string folderName)
    {
        var index = CurrentState.Folders.Max(x => x.Id) + 1;
        var folderModelUi = new FolderModelUi() { Id = index, Name = folderName, LastUpdated = DateTime.Now, Hidden = false };
        CurrentState.Folders.Add(folderModelUi);
        await SnapShotCallback.InvokeAsync();
    }

    public async Task MoveFolderPosition(int dragTargetFolderId, FolderModelUi folderDragPayload)
    {
        Console.WriteLine($"Firing MoveFolderPosition");
        var dragTargetIndex = CurrentState.Folders.FindIndex(x => x.Id == dragTargetFolderId);
        if (dragTargetIndex >= 0)
        {
            CurrentState.Folders.RemoveAll(x => x.Id == FolderDragPayload.Id);
            CurrentState.Folders.Insert(dragTargetIndex, folderDragPayload);
        }
        await InvokeAsync(StateHasChanged);
    }

    public async Task InsertNewBookmarkAtPosition(BookmarkModelUi dragTargetBookmark)
    {
        Console.WriteLine($"Firing InsertNewBookmarkAtPosition with a dragTargetBookmark of {dragTargetBookmark.Id} in Folder {dragTargetBookmark.FolderId}");

        var newIndex = CurrentState.Bookmarks.Max(x => x.Id) + 1;

        var p = CurrentState.Bookmarks.SingleOrDefault(x => x.Id == int.MaxValue);
        
        if (p != null)
        {
            return;
        }
        var placeholder = new BookmarkModelUi() { Id = int.MaxValue, FolderId = dragTargetBookmark.FolderId, Name = "Placeholder", Url = "https://placeholder.com" };

        var index = CurrentState.Bookmarks.FindIndex(x => x == dragTargetBookmark);
        
        if (index >= 0)
        {
            placeholder.FolderId = dragTargetBookmark.FolderId;
            CurrentState.Bookmarks.Insert(index, placeholder);
        }
        
        await InvokeAsync(StateHasChanged);
    }

    public async Task MoveBookmarkPosition(BookmarkModelUi dragTargetBookmark)
    {
        BookmarkDragPayload.FolderId = dragTargetBookmark.FolderId;
        var index = CurrentState.Bookmarks.FindIndex(x => x == dragTargetBookmark);
        Console.WriteLine($"MoveBookmarkPosition : Want to move bookmark '{BookmarkDragPayload.Name}' in Folder ID: '{dragTargetBookmark.FolderId}' to index {index}");
        if (index >= 0)
        {
            CurrentState.Bookmarks.RemoveAll(x => x == BookmarkDragPayload);
            CurrentState.Bookmarks.Insert(index, BookmarkDragPayload);
        }
        await InvokeAsync(StateHasChanged);
    }

    public Task MoveBookmarkToFolder(FolderModelUi target)
    {
        BookmarkDragPayload.FolderId = target.Id;
        return Task.CompletedTask;
    }

    public async Task RemoveBookmark(BookmarkModelUi linkToDelete)
    {
        CurrentState.Bookmarks.RemoveAll(x => x == linkToDelete);
        await SnapShotCallback.InvokeAsync();
    }

    public void Navigate(BookmarkModelUi linkToNavigate)
    {
        navigationManager.NavigateTo(linkToNavigate.Url, true);
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        var keys = e;
        if (e.CtrlKey)
        {
            if (e.Code == "KeyZ")
            {
                Console.WriteLine("Undo: Invoked");
                await UndoCallback.InvokeAsync();
            }
            else if (e.Code == "KeyY")
            {
                Console.WriteLine("Redo: Invoked");
                await RedoCallback.InvokeAsync();
            }
        }
    }

    public async Task EditBookmark(int bookmarkId)
    {
        IsEditMode = true;
        BookmarkToEdit = CurrentState.Bookmarks.Single(x => x.Id == bookmarkId);
        await Task.CompletedTask;
    }

    public async Task CancelEditBookmark()
    {
        IsEditMode = false;
        BookmarkToEdit = null;
        await Task.CompletedTask;
    }

    public async Task SaveEditBookmark(int id, string bookmarkName, string bookmarkUrl)
    {
        //todo validation
        //todo undo is REALLY funky here
        BookmarkToEdit.Name = bookmarkName;
        BookmarkToEdit.Url = bookmarkUrl;
        var bookmark = CurrentState.Bookmarks.Single(x => x.Id == id);
        bookmark.Name = bookmarkName;
        bookmark.Url = bookmarkUrl;

        await SnapShotCallback.InvokeAsync();
        await CancelEditBookmark();
    }

    public async Task DeleteFolder(int folderId)
    {
        CurrentState.Folders.RemoveAll(x => x.Id == folderId);
        CurrentState.Bookmarks.RemoveAll(x => x.FolderId == folderId);
        await SnapShotCallback.InvokeAsync();
    }

}