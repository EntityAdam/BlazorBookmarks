<div class="flex flex-col flex-grow mb-1 mx-2 w-64 resize-x overflow-auto bg-teal-300" style="flex-basis: auto;"
     draggable="true"
     dropzone="move"
     @ondragstart="((e) => HandleDragStart(FolderModel))"
     @ondragenter="((e) => HandleOnDragEnter())"
     @ondragleave="((e) => HandleOnDragLeave())"
     @ondragover="((e) => HandleDragOver(FolderModel))"
     @ondragover:preventDefault
     @ondrop="((e) => HandleDrop(FolderModel))"
     @ondrop:stopPropagation>
    <div class="@IsVisibleCssClass()" style="position:relative">
        @*TODO: Move the FolderTitle to the Folder Component*@
        <FolderTitle FolderId="@FolderModel.Id" FolderName="@FolderModel.Name" />
        <div class="@IsDragBoxShown() bg-teal-600 border-1" style="border:dotted;">
            <p style="position:absolute; left:5px; top:45px;">Drop bookmarks here</p>
            @*//change opacity 0 to hidden?*@
            <InputFile OnChange="OnInputFileChanged" multiple class="w-full" style="border:dotted; border-width:1; opacity:0;" />
        </div>
        <ul class="px-3 py-5" style="pointer-events:auto">
            @foreach (var bookmark in FolderContainer.CurrentState.Bookmarks.Where(x => x.FolderId == FolderModel.Id))
            {
                <Bookmark Model="@bookmark" />
            }
        </ul>
    </div>
</div>



@code {

    [CascadingParameter]
    public FolderContainer FolderContainer { get; set; }

    [Parameter]
    public FolderModelUi FolderModel { get; set; }


    private const int maximumFileCount = 400; //TODO: Test this to see if it's slow

    //convert to nullable?
    private int dragBoxTarget;

    private bool showDragBox = false;

    private bool isLoadingFiles = false; //TODO: use this to show a spinner?

    private string IsVisibleCssClass() => FolderModel.Hidden ? "invisible" : "visible";

    private string IsDragBoxShown() => showDragBox ? "block" : "hidden";

    private async Task OnInputFileChanged(InputFileChangeEventArgs args)
    {   
        //TODO: extract method
        isLoadingFiles = true;
        try
        {
            foreach (var file in args.GetMultipleFiles(maximumFileCount))
            {
                //TODO: Check for memory leak
                using MemoryStream memoryStream = new();
                await file.OpenReadStream().CopyToAsync(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                using StreamReader streamReader = new(memoryStream);
                var urlFileHeader = await streamReader.ReadLineAsync();
                var urlFileValue = await streamReader.ReadLineAsync();
                if (urlFileHeader == "[InternetShortcut]" && urlFileValue is not null)
                {
                    var filename = Path.GetFileNameWithoutExtension(file.Name);
                    var url = urlFileValue.Split('=')[1];
                    //TODO: this will reverse the order
                    //TODO: highlight new folders in some manner, and allow a cancellation?
                    await FolderContainer.InsertNewBookmarkAtTop(new BookmarkModelUi() { Name = filename, FolderId = FolderModel.Id, Url = url });
                }
            }
        }
        catch (Exception)
        {
            //TODO: present user with friendly error.
            //case: invalid url file --> unknown file type
            //case: application error --> ??
            throw;
        }
        isLoadingFiles = false;
        await FolderContainer.SnapShotCallback.InvokeAsync();
    }

    private async Task Delete()
    {
        await FolderContainer.DeleteFolder(FolderModel.Id);
    }

    private void HandleDragStart(FolderModelUi selectedCollection)
    {
        FolderContainer.FolderDragPayload = selectedCollection;
        FolderContainer.FolderDragPayload.Hidden = true;
    }

    private void HandleOnDragEnter()
    {

    }

    private void HandleOnDragLeave()
    {
        Console.WriteLine("Firing Folder HandleOnDragLeave");
    }

    private async Task HandleDragOver(FolderModelUi collection)
    {
        Console.WriteLine("Firing Folder HandleDragOver");

        if (FolderContainer.FolderDragPayload is null && FolderContainer.BookmarkDragPayload is null)
        {
            showDragBox = true;
        }
        else
        {
            if (FolderContainer.FolderDragPayload != null)
            {
                await FolderContainer.MoveFolderPosition(collection.Id, FolderContainer.FolderDragPayload);
            }

            if (FolderContainer.BookmarkDragPayload != null)
            {
                await FolderContainer.MoveBookmarkToFolder(collection);
            }
        }
    }

    private async Task HandleDrop(FolderModelUi dropTarget)
    {
        Console.WriteLine("Firing HandleDrop Folder");

        if (showDragBox) { showDragBox = false; }

        if (FolderContainer.FolderDragPayload != null)
        {
            FolderContainer.FolderDragPayload.Hidden = false;
            FolderContainer.FolderDragPayload = null;
            await FolderContainer.SnapShotCallback.InvokeAsync();
        }

        if (FolderContainer.BookmarkDragPayload != null)
        {
            FolderContainer.BookmarkDragPayload.Hidden = false;
            FolderContainer.BookmarkDragPayload = null;
            await FolderContainer.SnapShotCallback.InvokeAsync();
        }
    }
}
