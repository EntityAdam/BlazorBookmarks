<div class="flex flex-col flex-grow mb-1 mx-2 resize-x overflow-auto bg-indigo-100" style="flex-basis: auto;"
     draggable="true"
     dropzone="move"
     @ondragstart="((e) => HandleDragStart(Model))"
     @ondragenter="((e) => HandleOnDragEnter())"
     @ondragleave="((e) => HandleOnDragLeave())"
     @ondragover:preventDefault
     @ondragover="((e) => HandleDragOver(Model))"
     @ondrop="((e) => HandleDrop(Model))">

    <!--<div class="@IsVisibleCssClass" style="pointer-events:none;">-->
    <div class="@IsVisibleCssClass">
        <div class="flex justify-between">
            <FolderTitle FolderId="@Model.Id" FolderName="@Model.Name" />
            <DeleteIcon Id="@Model.Id" DeleteCallback="Delete" />
            <InputFile OnChange="OnInputFileChanged" multiple class="absolute mud-width-full mud-height-full overflow-hidden z-2" style="border:dotted; border-width:1; opacity:0;" />
        </div>
        <ul class="px-2 py-5" style="pointer-events:auto">
            @foreach (var b in Container.CurrentState.Bookmarks.Where(x => x.FolderId == Model.Id))
            {
                <Bookmark Model="@b" />
            }
        </ul>
    </div>
</div>



@code {
    [CascadingParameter]
    public FolderContainer Container { get; set; }

    [Parameter]
    public FolderModelUi Model { get; set; }

    private string IsVisibleCssClass => Model.Hidden ? "invisible" : "visible";

    private bool isLoadingFiles;

    private async Task OnInputFileChanged(InputFileChangeEventArgs e)
    {
        isLoadingFiles = true;
        try
        {
            foreach (var file in e.GetMultipleFiles(int.MaxValue))
            {
                using MemoryStream memoryStream = new();
                await file.OpenReadStream().CopyToAsync(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                using StreamReader streamReader = new(memoryStream);
                var result1 = await streamReader.ReadLineAsync();
                var result2 = await streamReader.ReadLineAsync();
                if (result1 == "[InternetShortcut]" && result2 is not null)
                {
                    var name = Path.GetFileNameWithoutExtension(file.Name);
                    var url = result2.Split('=')[1];
                    await Container.InsertNewBookmarkAtTop(new BookmarkModelUi() { Name = name, FolderId = Model.Id, Url = url });
                }
            }
        }
        catch (Exception)
        {
            throw;
        }
        isLoadingFiles = false;
        await Container.SnapShotCallback.InvokeAsync();
    }

    private async Task Delete()
    {
        await Container.DeleteFolder(Model.Id);
    }

    private void HandleEditFolderTitle()
    {
        Console.WriteLine("Edit Folder Title");
    }

    private void HandleDragStart(FolderModelUi selectedCollection)
    {
        Container.FolderDragPayload = selectedCollection;
        Container.FolderDragPayload.Hidden = true;
    }

    private void HandleOnDragEnter()
    {
    }

    private void HandleOnDragLeave()
    {
    }

    private async Task HandleDragOver(FolderModelUi collection)
    {
        Console.WriteLine("Firing Folder HandleDragOver");

        if (Container.FolderDragPayload != null)
        {
            await Container.MoveFolderPosition(collection.Id, Container.FolderDragPayload);
        }

        if (Container.BookmarkDragPayload != null)
        {
            await Container.MoveBookmarkToFolder(collection);
        }
    }

    private async Task HandleDrop(FolderModelUi dropTarget)
    {
        Console.WriteLine("Firing HandleDrop Folder");

        if (Container.FolderDragPayload != null)
        {
            Container.FolderDragPayload.Hidden = false;
            Container.FolderDragPayload = null;
            await Container.SnapShotCallback.InvokeAsync();
        }

        if (Container.BookmarkDragPayload != null)
        {
            Container.BookmarkDragPayload.Hidden = false;
            Container.BookmarkDragPayload = null;
            await Container.SnapShotCallback.InvokeAsync();
        }
    }

    [JSInvokable]
    public static void UrlDrop(string url)
    {
        var result = url.Replace(System.Environment.NewLine, string.Empty);
    }
}
